<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><title>WFST加权有限状态转换机-上 | Nighttellの小世界</title><meta name="author" content="Nighttell"><meta name="description" content="一个小菜鸡的博客"><meta name="keywords" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><link rel="icon" href="https://nighttellpic.netlify.app/head.jpg"><script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css"><link rel="stylesheet" href="/css/fonts.min.css"><script>const mixins={}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script><script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script><script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"><script src="/js/lib/highlight.js"></script><script src="/js/lib/preview.js"></script><link rel="stylesheet" href="/css/main.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="layout"><transition name="fade"><div id="loading" v-show="loading"><div id="loading-circle"><h2>LOADING</h2><p>加载过慢请开启缓存 浏览器默认开启</p><img src="/images/loading.gif"></div></div></transition><div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}"><nav id="desktop-menu"><a class="title" href="/"><span>NIGHTTELLの小世界</span> </a><a href="/"><i class="fa-solid fa-house fa-fw"></i> <span>&ensp;Home</span> </a><a href="/about"><i class="fa-solid fa-id-card fa-fw"></i> <span>&ensp;About</span> </a><a href="/archives"><i class="fa-solid fa-box-archive fa-fw"></i> <span>&ensp;Archives</span> </a><a href="/categories"><i class="fa-solid fa-bookmark fa-fw"></i> <span>&ensp;Categories</span> </a><a href="/tags"><i class="fa-solid fa-tags fa-fw"></i> <span>&ensp;Tags</span></a></nav><nav id="mobile-menu"><div class="title" @click="showMenuItems = !showMenuItems"><i class="fa-solid fa-bars fa-fw"></i> <span>&emsp;NIGHTTELLの小世界</span></div><transition name="slide"><div class="items" v-show="showMenuItems"><a href="/"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-house fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Home</div></div></a><a href="/about"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-id-card fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">About</div></div></a><a href="/archives"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-box-archive fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Archives</div></div></a><a href="/categories"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-bookmark fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Categories</div></div></a><a href="/tags"><div class="item"><div style="min-width:20px;max-width:50px;width:10%"><i class="fa-solid fa-tags fa-fw"></i></div><div style="min-width:100px;max-width:150%;width:20%">Tags</div></div></a></div></transition></nav></div><transition name="fade"><div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div></transition><div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'"><div class="article"><div><h1>WFST加权有限状态转换机-上</h1></div><div class="info"><span class="date"><span class="icon"><i class="fa-solid fa-calendar fa-fw"></i> </span>2025/7/9 </span><span class="category"><a href="/categories/%E7%AE%97%E6%B3%95/"><span class="icon"><i class="fa-solid fa-bookmark fa-fw"></i> </span>算法 </a></span><span class="tags"><span class="icon"><i class="fa-solid fa-tags fa-fw"></i> </span><span class="tag"><a href="/tags/%E7%AE%97%E6%B3%95/" style="color:#00a596">算法</a> </span><span class="tag"><a href="/tags/%E5%8A%A0%E6%9D%83%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E6%9C%BA/" style="color:#ffa2c4">加权有限状态转换机</a> </span><span class="tag"><a href="/tags/WFST/" style="color:#03a9f4">WFST</a></span></span></div><div class="content" v-pre><p>WFST(Weighted Finite-State Transducer)：加权有限状态转换机，由有限状态接收机拓展而来，在领域常被称为“解码器”。<br>WFST不需要更新（​<strong>静态解码网络</strong>​）</p><p>然后先了解一下FA有穷自动机,<br>DFA确定有穷自动机<br>NFA非确定有穷自动机</p><hr><h1 id="有穷自动机fa">有穷自动机(FA)</h1><ul><li>自动机(Automaton)​：就是一个代码块,只做一件事——接收输入值，和状态值，输出同为状态值的结果。</li><li>​有限(Finite)​：是指自动机接收、输入的状态种类是有限的。</li><li>​确定(Deterministic )：是指自动机的输出状态是单一的一个状态。</li></ul><p>​<strong>​关键组成部分​</strong>​：</p><ul><li>​<strong>​状态（Q）​</strong>​：一个有限的、非空的状态集合。这些状态代表系统可能处于的内部配置。例如：<code>&#123;q0, q1, q2&#125;</code>。</li><li>​<strong>​输入符号（Σ）​</strong>​：一个有限的、非空的输入字母表（符号集合）。例如：<code>&#123;0, 1&#125;</code>。</li><li>​<strong>​起始状态（q₀ ∈ Q）​</strong>​：机器开始处理输入字符串时处于的状态。</li><li>​<strong>​接受状态/终结状态（F ⊆ Q）​</strong>​：一个状态集合。如果机器在处理完整个输入字符串后​<strong>​停在这个集合中的某个状态​</strong>​，则该字符串被​<strong>​接受​</strong>​。</li><li>​<strong>​转移函数（δ : Q × Σ → Q）​</strong>​： 核心部分！这是一个​<strong>​函数​</strong>​，定义了系统如何从一个状态转换到另一个状态。<ul><li>给定一个​<strong>​当前状态（q ∈ Q）​</strong>​和一个​<strong>​当前输入符号（s ∈ Σ）​</strong>​，转移函数​<strong>​唯一确定地指定下一个状态（q' ∈ Q）​</strong>​。</li><li>数学表示：<code>δ(q, s) = q'</code></li></ul></li></ul><hr><h2 id="nfa示例">NFA示例</h2><ul><li>think：NFA可以有丝分裂（可以保留多种可能）</li><li>注意：在非确定有限自动机（NFA）中，​<strong>​ε条件​</strong>​（epsilon transition，或称ε转移）是一种特殊的转移方式，表示自动机可以在​<strong>​不消耗任何输入符号​</strong>​的情况下从一个状态转移到另一个状态。ε（epsilon）代表空字符串（即没有输入字符）。</li><li>再注意：<strong>a*b​</strong>​（即任意数量的 <code>a</code> 后接一个 <code>b</code>），​<strong>​<code>a*b*c</code>​</strong>​ 描述的语言是：​<strong>​任意数量的 <code>a</code>（包括零个），后接任意数量的 <code>b</code>（包括零个），最后以一个 <code>c</code> 结尾​</strong>​。</li></ul><p><strong>设计目标：​</strong>​ 让机器能够识别以“01”结尾的串（比如：<code>"01"</code>, <code>"101"</code>, <code>"1101"</code>, <code>"010101"</code> 等），拒绝不以“01”结尾的串（比如：<code>"00"</code>, <code>"10"</code>, <code>"11"</code>, <code>"010"</code> 等）。</p><p>​<strong>​状态设想：​</strong>​</p><ul><li>​<strong>​<code>q0</code>​</strong>​: 初始状态，也可以理解为“还没有开始认真寻找'01'结尾”或者“刚处理完可能的不合格结尾，重新开始搜索”的状态。</li><li>​<strong>​<code>q1</code>​</strong>​: 表示机器​<em>最近读到了一个'0'</em>​，并且​<strong>​希望下一个读到的字符是'1'​</strong>​，这个'1'如果出现，就可能是我们要找的结尾<code>01</code>的一部分。</li><li>​<strong>​<code>q2</code>​</strong>​: ​<strong>​接受状态​</strong>​，表示机器已经成功地读到了所需的结尾<code>01</code>。</li></ul><p>​<strong>​关键转移 <code>δ(q0, 0) = &#123;q0, q1&#125;</code> 的妙处：​</strong>​</p><p>当机器处于起始状态 <code>q0</code>，并且读到一个字符 <code>'0'</code> 时，这个非确定性转移给了机器​<strong>​两种选择（或可能性，或路径）​</strong>​：</p><ol type="1"><li>​<strong>​选择停留在 <code>q0</code> (路径1):​</strong>​<ul><li>​<strong>​想法：​</strong>​ “我刚读到的这个<code>0</code>，可能不是那个作为结尾<code>01</code>开头的<code>0</code>。它可能是字符串中间的一个普通<code>0</code>，或者是以后可能出现的<code>01</code>结尾<code>0</code>之前的<code>0</code>。我需要继续按部就班地处理输入。”</li><li>​<strong>​行为：​</strong>​ 机器保持状态 <code>q0</code>。</li><li>​<strong>​目的：​</strong>​ 这种方式让机器​<strong>​不会错过后面可能出现的、更接近结尾的<code>0</code>​</strong>​（也就是真正的结尾<code>01</code>里的那个<code>0</code>）。</li><li>​<strong>​举例解释 (路径1为主)：​</strong>​<ul><li>输入串: <code>"1001"</code> (接受，以<code>01</code>结尾)</li><li>步骤:<ul><li>读 <code>'1'</code>: 只能是 <code>δ(q0, 1) -&gt; q0</code> (留在<code>q0</code>)</li><li>读 <code>'0'</code>: <code>δ(q0, 0) = &#123;q0, **q1**&#125;</code> -&gt; 选择 <code>q0</code> (停留)</li><li>读 <code>'0'</code>: <code>δ(q0, 0) = &#123;q0, q1&#125;</code> -&gt; 选择 <code>q0</code> (停留) <em>(注意：这里有两个连续的<code>0</code>，但第一个<code>0</code>我们选择了<code>q0</code>路径，所以第二个<code>0</code>时我们还在<code>q0</code>)</em></li><li>读 <code>'1'</code>: <code>δ(q0, 1) -&gt; q0</code> (停留在<code>q0</code>) -&gt; ​<strong>​结束在<code>q0</code> (非接受状态)​</strong>​ 😱 等等，出问题了！我们期望接受<code>"1001"</code>。这条路径失败了！​<strong>​但是​</strong>​，非确定性允许我们回溯，看看在第二个字符<code>0</code>读入时，选择另一条路径会怎样...</li></ul></li></ul></li></ul></li><li>​<strong>​选择转移到 <code>q1</code> (路径2):​</strong>​<ul><li>​<strong>​想法：​</strong>​ “我读到的这个<code>0</code>​<strong>​可能是​</strong>​我们正在等待的结尾<code>01</code>的起始<code>0</code>！我要赌一把，进入一个'期待<code>1</code>'的状态。”</li><li>​<strong>​行为：​</strong>​ 机器转换到状态 <code>q1</code>。这个状态意味着：如果​<strong>​下一个字符​</strong>​读到的​<strong>​正好是<code>1</code>​</strong>​，那么我们就成功捕获到了结尾<code>01</code>，转移到接受状态<code>q2</code>。</li><li>​<strong>​目的：​</strong>​ 这是为了​<strong>​立即尝试匹配以当前读到的<code>0</code>开头的潜在<code>01</code>结尾​</strong>​。</li><li>​<strong>​举例解释 (路径2为主)：​</strong>​<ul><li>输入串: <code>"1001"</code> (接受，以<code>01</code>结尾)</li><li>步骤:<ul><li>读 <code>'1'</code>: <code>δ(q0, 1) -&gt; q0</code> (留在<code>q0</code>)</li><li>读 <code>'0'</code>: <code>δ(q0, 0) = &#123;q0, **q1**&#125;</code> -&gt; ​<strong>​选择 <code>q1</code> (这条是新路径!)​</strong>​</li><li>读 <code>'0'</code>: <code>δ(q1, 0) = ？</code> (看转移函数定义) -&gt; 根据上面的定义 <code>δ(q1, 0) = ?</code> 没定义！等下看我们前面定义 <code>δ(q1, 1) = q2</code>，但 <code>δ(q1, 0)</code> 我们没定义。按NFA规则，没定义意味着 <code>δ(q1, 0) = ∅</code> (空集)。读 <code>'0'</code> 时没有可用的转移！ -&gt; ​<strong>​这条路径卡死了​</strong>​ 😱</li></ul></li><li>​<strong>​还是不行！​</strong>​</li></ul></li></ul></li></ol><p>​<strong>​改进设计：处理连续 <code>0</code> 的问题 - 加状态 <code>q1</code> 遇到 <code>0</code> 的转移​</strong>​</p><p>第二次尝试（路径2）在第三个字符<code>0</code>卡住了。问题在于：当处于<code>q1</code>（期待<code>1</code>的状态）却读到了<code>0</code>时，机器不知道怎么处理了。我们需要让机器能从<code>q1</code>状态读<code>0</code>继续存活。</p><ul><li>​<strong>​状态 <code>q1</code> 遇到 <code>'0'</code> 时：​</strong>​<ul><li>​<strong>​想法：​</strong>​ “糟糕，我刚在<code>q1</code>期待一个<code>1</code>来结束<code>01</code>，但读到的是<code>0</code>。这意味着前面读到的那个让我进入<code>q1</code>的<code>0</code>​<strong>​并不是​</strong>​结尾<code>01</code>的起始<code>0</code>（或者说，真正的结尾<code>01</code>还没开始）。怎么办？没关系，​<strong>​刚读到的这个新的<code>0</code>，它有可能成为新的潜在结尾<code>01</code>的起始<code>0</code>啊！​</strong>​”</li><li>​<strong>​设计：​</strong>​ <code>δ(q1, 0) = &#123;q1&#125;</code> (或者更严格地说，NFA中有时会写成<code>δ(q1, 0) = &#123;q1&#125;</code>)</li><li>​<strong>​行为：​</strong>​ 机器​<strong>​保持在 <code>q1</code> 状态​</strong>​。​<strong>​本质上是把这个新读到的<code>0</code>当作潜在结尾<code>01</code>的第一个<code>0</code>​</strong>​，并且继续期待下一个字符是<code>1</code>（因为现在它还在<code>q1</code>状态）。</li></ul></li></ul><p>​<strong>​改进后的NFA定义 (关键修正):​</strong>​</p><ul><li><code>Q = &#123;q0, q1, q2&#125;</code></li><li><code>Σ = &#123;0, 1&#125;</code></li><li><code>q0 = q0</code></li><li><code>F = &#123;q2&#125;</code></li><li><code>δ</code>:<ul><li><code>δ(q0, 0) = &#123;q0, q1&#125;</code> ​<strong>​// 读<code>0</code>： 可留在<code>q0</code>或转到<code>q1</code>（非确定性）​</strong>​</li><li><code>δ(q0, 1) = &#123;q0&#125;</code> ​<strong>​// 读<code>1</code>：只能留在<code>q0</code>​</strong>​</li><li><code>δ(q1, 0) = &#123;q1&#125;</code> ​<strong>​// (新增/修正！) 读<code>0</code>：保持在<code>q1</code>(把这个新<code>0</code>当作新起点)​</strong>​</li><li><code>δ(q1, 1) = &#123;q2&#125;</code> ​<strong>​// 读<code>1</code>：满足期待，进入接受状态<code>q2</code> (关键匹配点!)​</strong>​</li><li><code>δ(q2, 0) = ∅</code> ​<strong>​// 接受状态读任何字符都无转移（可选，也可定义，但通常到接受状态后行为不重要）​</strong>​</li><li><code>δ(q2, 1) = ∅</code> ​<strong>​// 同上​</strong>​</li></ul></li></ul><p>​<strong>​示例详解: 输入 <code>"1001"</code> (接受)​</strong>​</p><ul><li>​<strong>​起始:​</strong>​ <code>当前活动状态集 = [q0]</code></li><li>​<strong>​读第一个字符 <code>'1'</code>:​</strong>​<ul><li>只有 <code>q0</code> 状态 -&gt; <code>δ(q0, 1) = &#123;q0&#125;</code></li><li>​<strong>​新活动状态集 = [q0]​</strong>​</li></ul></li><li>​<strong>​读第二个字符 <code>'0'</code>:​</strong>​<ul><li><code>q0</code> 状态 -&gt; <code>δ(q0, 0) = &#123;q0, q1&#125;</code> ​<strong>​(非确定性分支点!)​</strong>​</li><li>​<strong>​新活动状态集 = [q0, q1]`​</strong>​ (并行追踪两条路径)</li></ul></li><li>​<strong>​读第三个字符 <code>'0'</code>:​</strong>​<ul><li>​<strong>​处理 <code>q0</code> 状态:​</strong>​ <code>δ(q0, 0) = &#123;q0, q1&#125;</code> (又分支！但在当前路径上选择) -&gt; 假设选择 <code>q0</code> -&gt; ​<strong>​路径1状态: <code>q0</code>​</strong>​</li><li>​<strong>​处理 <code>q1</code> 状态:​</strong>​ <code>δ(q1, 0) = &#123;q1&#125;</code> -&gt; ​<strong>​路径2状态: <code>q1</code>​</strong>​ ​<strong>​(这里利用了新定义的转移！)​</strong>​</li><li>​<strong>​新活动状态集 = [q0, q1]`​</strong>​ (两条路径仍然活跃)</li></ul></li><li>​<strong>​读第四个字符 <code>'1'</code>:​</strong>​<ul><li>​<strong>​处理 <code>q0</code> 状态:​</strong>​ <code>δ(q0, 1) = &#123;q0&#125;</code> -&gt; ​<strong>​路径1状态: <code>q0</code>​</strong>​</li><li>​<strong>​处理 <code>q1</code> 状态:​</strong>​ <code>δ(q1, 1) = &#123;q2&#125;</code> -&gt; ​<strong>​路径2状态: <code>q2</code>​</strong>​ ​<strong>​!!!!! (匹配成功!)​</strong>​</li><li>​<strong>​新活动状态集 = [q0, q2]`​</strong>​</li></ul></li><li>​<strong>​结束检查:​</strong>​ 当前活动状态集 <code>[q0, q2]</code> ​<strong>​包含接受状态 <code>q2</code>​</strong>​ -&gt; ​<strong>​接受该字符串！​</strong>​</li></ul><blockquote><p>​<strong>​关键点解释:​</strong>​</p><ul><li>当第二个字符 <code>'0'</code> 被读取时，机器通过非确定性创建了两条并行的“世界线”（路径）。一条（<code>q0</code> -&gt; 选择 <code>q0</code>）继续漫无目的地前进；另一条（<code>q0</code> -&gt; 选择 <code>q1</code>）则严肃地认为这可能是结尾 <code>01</code> 的开始。</li><li>当第三个字符 <code>'0'</code> 到来：<ul><li>在“漫无目的”的那条线上（状态 <code>q0</code>），机器可以继续停留或者开启新的 <code>q1</code> 分支，但这条线在本例中继续选择停留 <code>q0</code>。</li><li>在“严肃对待”的那条线上（状态 <code>q1</code>），机器期待的是一个 <code>1</code>，但读到了 <code>0</code>。我们​<strong>​修正后的转移 <code>δ(q1, 0) = &#123;q1&#125;</code> 救活了这条路​</strong>​！它把这个新 <code>0</code> 解释为一个<em>新的</em>潜在 <code>01</code> 起始符（就像最开始进入 <code>q1</code> 时看待那个 <code>0</code> 一样），所以机器保持 <code>q1</code> 状态，期待下一个是 <code>1</code>。</li></ul></li><li>当第四个字符 <code>'1'</code> 到来：<ul><li>在“漫无目的”的那条线（<code>q0</code>），读 <code>1</code> 只能留在 <code>q0</code>。</li><li>在“严肃对待”的那条线（<code>q1</code>），读 <code>1</code> 完美匹配了它期待的模式！ <code>δ(q1, 1) = q2</code>。这条路成功地转移到了接受状态 <code>q2</code>。</li></ul></li><li>因为最终状态集中包含 <code>q2</code>（这条路径成功），所以整体接受 <code>"1001"</code>。另一条路径最终在 <code>q0</code> 失败了，但​<strong>​NFA只看是否有至少一条路径成功​</strong>​！</li></ul></blockquote><hr><hr><p>下图来源于知乎<br>展示了由NFA到DFA的确定化</p><p><img src="https://picx.zhimg.com/v2-6461666c83aa4ac1aa761dc19589d511_1440w.jpg"></p><h3 id="一为什么要确定化why">一、为什么要确定化（Why）？</h3><ol type="1"><li>​<strong>​去除不确定性：​</strong>​ NFA 在同一个状态下，对于同一个输入符号，可能有多个转移选项，甚至可以通过 ε（空串）进行转移而不消耗任何输入字符。这种不确定性给 NFA 的执行（模拟运行）带来了复杂性，通常需要回溯或并行探索所有可能的路径。</li><li>​<strong>​简化实现和执行：​</strong>​ DFA 是确定性的，即：<ul><li>没有 ε 转移。</li><li>每个状态对于每个可能的输入符号，​<strong>​有且只有一个​</strong>​确定的后继状态。<br>这使得 DFA 的执行非常简单高效：从一个状态读取一个输入符号，必然转移到一个唯一确定的下一个状态。</li></ul></li><li>​<strong>​统一模型与算法：​</strong>​ 许多与正则语言相关的理论（如最小化）和算法（如词法分析）是建立在 DFA 模型之上的。将 NFA 转换为等效的 DFA 使我们能够利用这些更成熟、更高效的理论和工具。</li><li>​<strong>​基础性证明：​</strong>​ 该转换过程本身证明了 ​<strong>​NFA 和 DFA 在识别语言的能力上是等价的​</strong>​（即它们都识别精确的正则语言集）。这是计算理论中的一个重要结论。</li></ol><h3 id="二确定化流程流程是什么---子集构造法subset-construction">二、确定化流程（流程是什么？） - 子集构造法（Subset Construction）</h3><p>👍下面的好像默认自己的状态可以由空跳转。（也可能是NFA的特性）-<br><del>我没看见自环</del></p><hr><p>核心思想是将 NFA 中的一组可能状态（一个“集合”）打包成 DFA 的一个​<strong>​单个状态​</strong>​。DFA 的状态对应于 NFA 状态的​<strong>​子集​</strong>​。<br>子集构造的核心概念是<strong>ϵ</strong>-闭包(<strong>ϵ</strong>−<strong>c</strong>l<strong>o</strong>s<strong>u</strong>r<strong>e</strong>)算法。比如<a target="_blank" rel="noopener" href="https://fancyerii.github.io/books/wfst/#subset-construction-1">下图</a>所示的NFA，它可以识别的语言是”a*b*c*“(请读者验证)。<strong>ϵ</strong>-闭包算法的输入是一个NFA的状态集合，比如{1}，它的输出也是一个状态集合，其中输出集合的每一个状态都是可以从输入状态经过全是<strong>ϵ</strong>的边跳转到这个状态。因此如果输入是{1}，那么它的<strong>ϵ</strong>-闭包是集合{1,2}，因为1可以通过空跳转到自己，而1也可以通<strong>ϵ</strong>跳转到2。类似的输入{0}的<strong>ϵ</strong>-闭包是集合{0,1,2}，因为0可以通过<strong>ϵ</strong>跳转到1，而1又可能通过<strong>ϵ</strong>跳转到2。</p><p><a href=""><img src="https://fancyerii.github.io/img/wfst/subset-construction-1.png"></a><em>图：识别”a*b*c*“的NFA</em></p><p><a href=""><img src="https://fancyerii.github.io/img/wfst/subset-construction-2.png"></a><em>图：识别”a*b*c*“的DFA</em></p><p>子集构造的过程如<a target="_blank" rel="noopener" href="https://fancyerii.github.io/books/wfst/#subset-construction-3">下图</a>所示。NFA的初始状态是0，我们首先得到它的<strong>ϵ</strong>-闭包{0,1,2}，我们把它作为DFA的一个状态，因为它包含NFA的初始状态0，因此它也是DFA的初始状态；同时它包含NFA的终止状态2，因此它也是DFA的终止状态。</p><p>接着我们看DFA的状态{0,1,2}输入字母a的情况，状态0输入a还是0，而状态1和2不能输入a，因此{0,1,2}输入a可以得到0，而0的<strong>ϵ</strong>-闭包是{0,1,2}，因此{0,1,2} -a-&gt;{0,1,2}。再看{0,1,2}输入b的情况，0和2不能输入b，只有状态1遇到b后还是状态1，因此{0,1,2}遇到b的”直接”输出是{1}，而{1}的<strong>ϵ</strong>-闭包是{1,2}，因此最终{0,1,2}-b-&gt;{1,2}。类似的，我们可以得到{0,1,2}-c-&gt;{2}。</p><p>这个时候的状态除了{0,1,2}又多了{1,2}和{2}，我们再来看第二行状态{1,2}的跳转。首先是{1,2}输入a，跳不到任何状态，因此输出是空集<strong>∅</strong>∅，空集的<strong>ϵ</strong>-闭包还是空集。然后是{1,2}输入b，2遇到b没有，1遇到b还是1，然后1的<strong>ϵ</strong>-闭包是{1,2}，因此{1,2}-b-&gt;{1,2}。后面的过程都是类似的，当处理完空集后没有产生任何新的状态，因此整个过程结束。</p><p><a href=""><img src="https://fancyerii.github.io/img/wfst/subset-construction-3.png"></a><em>图：通过子集构造把NFA转换成DFA</em></p><p>学习资料来源：</p><ul><li><a target="_blank" rel="noopener" href="https://fancyerii.github.io/books/wfst/" class="uri">https://fancyerii.github.io/books/wfst/</a></li><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/369054845" class="uri">https://zhuanlan.zhihu.com/p/369054845</a></li><li>deepseek</li><li></li></ul></div><div id="comment"><div id="giscus-container" class="giscus"></div></div></div><footer id="footer"><div id="footer-wrap"><div>&copy; 2022 - 2025 Nighttellの小世界 <span id="footer-icon"><i class="fa-solid fa-font-awesome fa-fw"></i> </span>&commat;Nighttell</div><div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp; <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a></div></div></footer></div><transition name="fade"><div id="preview" ref="preview" v-show="previewShow"><img id="preview-content" ref="previewContent"></div></transition></div><canvas id="fireworks" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:32767"></canvas><script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script><script src="/js/fireworks.min.js"></script><canvas id="background" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1"></canvas><script src="/js/background.min.js"></script><script src="/js/main.js"></script><script src="https://giscus.app/client.js" data-repo="Nighttell/comment" data-repo-id="R_kgDOKS6dPw" data-category="Announcements" data-category-id="DIC_kwDOKS6dP84CZRPV" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin async></script></body></html>